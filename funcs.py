import sys
import wave
import struct
import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
from peakutils.peak import indexes

#def main(argv):
#    audio_data = input_audio(argv[1])
#    print(audio_data)

# Input: path of CSV file containing h[n] generated by MATLAB
# Output: numpy array of h[n] values
def parse_hn(file_path):
    # hn = np.array([])
    hn_arr = []

    with open(file_path, 'r') as fp:
        file_data = fp.read().strip('\n').split(",")

    for data in file_data:
        hn_arr.append(float(data))

    return hn_arr


# Input: path of .wav audio file
# Output: numpy array of audio data values (only left channel if .wav has more than 1 channel)
def input_audio(file_path):
    # audio_data = np.array([])
    audio_data = []

    wave_file = wave.open(file_path, 'r')
    num_frames = wave_file.getnframes()

    for index in range(num_frames):
        wave_data = wave_file.readframes(1)
        data = struct.unpack("<h", wave_data)
        audio_data.append(float(data[0]))

    wave_file.close()

    return audio_data


# Input:
#   xn: data sequence to filter
#   hn: impulse response sequence
# Output: filtered sequence
def filter_data(xn, hn):
    yn = np.convolve(xn, hn, mode='valid')
    return yn


# Input: xn: data sequence to take short time fourier transform of
# Output: stft result
def do_stft(xn, fs):
    nperseg = 4096;
    noverlap = 0;
    nfft = nperseg;

    s = np.array([])
    f, t, Zxx = signal.stft(xn, fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)
#    plt.pcolormesh(t, f, np.abs(Zxx), vmin=0) #, vmax=amp)
#    plt.title('STFT Magnitude')
#    plt.ylabel('Frequency [Hz]')
#    plt.xlabel('Time [sec]')
#    plt.show()

    return Zxx

def stft2sigpower(s):
    sig_power = np.sum(np.abs(s),0)
    return sig_power

# Input: array of signal powers over time
# Output: peak values in sig_power and locations as indices
def findpeaks(sig_power):
    peaks = np.array([])
    peak_idx = np.array([])

    peak_idx = indexes(sig_power, thres=7.0/max(sig_power), min_dist=2)
    #peak_idx = signal.find_peaks_cwt(sig_power, np.arange(1,4), noise_perc=2)
    peaks = np.array([sig_power[idx] for idx in peak_idx])
    return peaks, peak_idx


#if __name__ == "__main__":
#    main(sys.argv)
